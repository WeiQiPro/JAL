let x := 10;                                //auto initializes i32
const xx := 12;
let lptr := &x;                             //points to address of x
const cptr: *const i32 = &xx;               // points to read only address of xx
let xx_value := *cptr;                      //reads address of immutable i32 variable and becomes the value of the address
let x_value := *lptr;                       //reads address of mutable i32 variable and becomes the value of the address
*lptr = 9; //x is now 9
*cptr = 10; // throws an error. Not allowed.
                                            // const cptr := *x; const ptr doesn't allow mutable data, use let instead.

let y: f32 = 32.0;                          // initializes f32

const A := 3.14;                            // this is an float or f32 but is immutable

let title: string = "Hello World";          // initializes an u8 char array

let hello := "Hello";                       // initializes an u8 char array

let world: [*]u8 = " World";                // initializes an u8 char array

const program := {                          // allow anonymous structs.
    title := "Hello";
    x: i32 = 999;
    points: [10]i32 = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8];
};

let canModMe: Struct = {                    // can modify and change variables with the same type of data
    title := "Hello"; 
    x: i32 = 999;
    points: [5]i32 = [1, 2, 3, 4, 5];
};

print(canModMe.points[0])                   // array indices start at 0; Should print "1";

enum State {                                // enums can be dynamically assigned a value. enums start at 0
    IDLE,
    RUNNING,
    SLEEPING
}

enum StateStrings {                         // types must be explicit and present throughout all
    IDLE = "idle",
    RUN = "run",
    SLEEP = "sleep",
}

struct Vec2 {
    f32 x;                                  // member is f32
    f32 y;                                  // member is f32

    Modify
        add: fn(self, v2: Vec2);            // add mod decleration to show this function is mutating variables of a struct.

    Static
        Vec2 addTwo: fn(v1: Vec2, v2: Vec2); 
                                            // static method, returns new Vec2

}

Vec2.add(v2: Vec2) {
    self.x += v2.x;
    self.y += v2.y;
}

Vec2.addTwo(v1: Vec2, v2: Vec2) {
    return Vec2 { v1.x + v2.x, v1.y + v2.y } 
                                            // positional initialization
}

struct MyStruct {
    i32 x;                                  // member is i32
    f32 y;                                  // member is f32
    u32 z;                                  // member is unsigned 32
    string title;                           // array of u8 char
    Vec2 position;                          // member is a struct
    void add: fn(self, vel: Vec2);          // no return type
    MyStruct new: fn(x: i32, y: f32, z: u32); 
                                            // creates a struct

    Static
        f32 sub: fn(a: f32, b: f32);        // returns f32
}

MyStruct.add(vel: Vec2) {
    self.position.add(vel); 
                                            // fixed: self is implicit for instance methods
}

MyStruct.sub(a: f32, b: f32) {
    return a - b;
}

MyStruct.new(x, y, z) {
    return MyStruct { x, y, z, "", Vec2 { 0.0, 0.0 } } 
                                            // positional initialization, all members required
}

fn getTotalAverage(numbers: []i32): i32 {
    let average := 0;
    
    for number .. numbers {
        average += number;
    }
    average = average / numbers.len();
    return average;
}

fn main() {

    let done := false                       // true or false are of type boolean
    let skip := true

    for (let i := 0; i < title.len(); i++) {
        print(title[i]);
    }

    while true {
        if done { break; }
        if skip { continue; }
    }

    let result := 0;                        // no variable can be null or undefined

    if (x + x == 10) {
        result = 10;
    } else if (x + x >= 10) {
        result = x**;                       // square x, equivalent to x * x
    } else if (x - xx == 2) {
        result = x ^ x;                     // exponential
    } else {
        result = x/xx;
    }

    return result;
}

// will want to add bitwise operations

// *= multiply
// /= divide
// += add
// -= sub
// % mod
// ** multiple by self
// ++ add one
// -- sub one
// ==, >=, <=, <, > comparisons